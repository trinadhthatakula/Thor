default_platform(:android)

platform :android do
  desc "Build and Distribute with Auto-Incremented Version Code"
  lane :distribute do

    # --- 0. PREPARATION ---
    # Define roots to avoid relative path confusion later
    fastlane_dir = Dir.pwd
    project_root = File.expand_path("..", fastlane_dir)
    gradle_properties_path = File.join(project_root, "gradle.properties")

    # --- 1. CONFIGURATION ---
    UI.message("ğŸ“ Reading configuration from: #{gradle_properties_path}")

    unless File.exist?(gradle_properties_path)
      UI.user_error!("âŒ gradle.properties not found at #{gradle_properties_path}")
    end

    # Robust Property Parsing (Handles spaces, comments, and empty lines)
    properties = File.readlines(gradle_properties_path)
                     .map(&:strip)
                     .reject { |l| l.empty? || l.start_with?('#') }
                     .map { |l| l.split('=', 2).map(&:strip) }
                     .to_h

    initial_version_code = properties["initialVersionCode"]&.to_i
    UI.user_error!("âŒ 'initialVersionCode' missing in gradle.properties") unless initial_version_code

    # --- 2. VERSION MANAGEMENT ---
    UI.message("ğŸ” Fetching latest version from Play Store (Internal Track)...")

    begin
      # Fetch all version codes from the track to find the max
      latest_store_codes = google_play_track_version_codes(track: "internal")
      latest_version_from_store = latest_store_codes.max
    rescue => ex
      UI.important("âš ï¸  Could not fetch version from Play Store (First run?): #{ex.message}")
      latest_version_from_store = nil
    end

    if latest_version_from_store.nil?
      new_version_code = initial_version_code
      UI.message("ğŸ†• No existing Store version found. Starting with initial: #{new_version_code}")
    else
      # Ensure we never go backwards, even if initialVersionCode is lower than Store
      new_version_code = [latest_version_from_store, initial_version_code].max + 1
      UI.message("â¬†ï¸  Incrementing version: #{latest_version_from_store} -> #{new_version_code}")
    end

    # --- 3. VERSION NAME CALCULATION ---
    # CRITICAL FIX: Run this command specifically from the project root
    new_version_name = ""
    Dir.chdir(project_root) do
      # We use -q (quiet) to ensure we only capture the print output
      new_version_name = sh("./gradlew -q app:printVersionName -PversionCode=#{new_version_code}").strip
    end

    UI.message("âœ… Calculated Version Name: #{new_version_name}")

    # Save version name for the GitHub Actions workflow to pick up
    version_name_file = File.join(fastlane_dir, "version_name.txt")
    File.write(version_name_file, new_version_name)

    # --- 4. BUILD ARTIFACTS ---
    # Clean is mandatory for production builds to avoid caching issues
    gradle(
      task: "clean bundleStoreRelease",
      project_dir: project_root, # Explicitly tell Fastlane where the root is
      properties: {
        "versionCode" => new_version_code,
        "android.injected.version.code" => new_version_code # Safety injection
      }
    )

    generated_aab_path = lane_context[SharedValues::GRADLE_AAB_OUTPUT_PATH]
    UI.user_error!("âŒ Gradle failed to return an AAB path.") unless generated_aab_path

    # Build the APK for the GitHub Release (FOSS flavor)
    gradle(
      task: "copyFossReleaseApk",
      project_dir: project_root,
      properties: { "versionCode" => new_version_code }
    )

    # --- 5. DEPLOY ---
    upload_to_play_store(
      track: 'internal',
      release_status: 'completed',
      aab: generated_aab_path,
      skip_upload_metadata: true,
      skip_upload_images: true,
      skip_upload_screenshots: true,
      skip_upload_apk: true
    )

    UI.success("ğŸš€ Successfully deployed version #{new_version_name} (#{new_version_code})!")
  end
end