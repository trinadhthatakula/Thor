default_platform(:android)

platform :android do

  # --- HELPER: Common Build Logic ---
  # REPRODUCIBILITY UPDATE:
  # This lane now strictly uses gradle.properties as the source of truth.
  # The 'version_code' argument is preserved only for manual overrides (re-building old commits).
  def prepare_release_artifacts(upload_to_store: false, version_code: nil)
    # 1. PREPARATION
    fastlane_dir = Dir.pwd
    project_root = File.expand_path("..", fastlane_dir)
    gradle_properties_path = File.join(project_root, "gradle.properties")

    # 2. CONFIGURATION & CHECKS
    UI.message("ğŸ“ Reading configuration...")
    unless File.exist?(gradle_properties_path)
      UI.user_error!("âŒ gradle.properties not found at #{gradle_properties_path}")
    end

    # Parse properties
    properties = File.readlines(gradle_properties_path)
                     .map(&:strip)
                     .reject { |l| l.empty? || l.start_with?('#') }
                     .map { |l| l.split('=', 2).map(&:strip) }
                     .to_h

    # 3. DETERMINE VERSION CODE (Source of Truth Logic)
    final_version_code = nil

    if version_code
      # A. Manual Override (e.g., triggering a build for a specific historical version)
      final_version_code = version_code.to_i
      UI.important("âš ï¸  Using MANUAL version code override: #{final_version_code}")
    else
      # B. Standard: Read from File (Reproducible)
      final_version_code = properties["versionCode"]&.to_i
      UI.user_error!("âŒ 'versionCode' missing in gradle.properties") unless final_version_code
      UI.message("âœ… Using defined version code from properties: #{final_version_code}")
    end

    # 4. GET VERSION NAME
    # We let Gradle calculate the name based on the code we just determined
    new_version_name = ""
    Dir.chdir(project_root) do
      new_version_name = sh("./gradlew -q app:printVersionName -PversionCode=#{final_version_code}").strip
    end

    UI.message("ğŸ“¦ Build Target: v#{new_version_name} (#{final_version_code})")

    # Save for GitHub Actions steps
    File.write(File.join(project_root, "version_name.txt"), new_version_name)
    File.write(File.join(project_root, "version_code.txt"), final_version_code.to_s)

    # 5. BUILD ARTIFACTS
    build_tasks = "clean copyStoreReleaseApk copyFossReleaseApk"
    build_tasks += " bundleStoreRelease" if upload_to_store

    gradle(
      task: build_tasks,
      project_dir: project_root,
      properties: {
        "versionCode" => final_version_code,
        "android.injected.version.code" => final_version_code
      }
    )

    # 6. DEPLOY (Conditional)
    if upload_to_store
      generated_aab_path = lane_context[SharedValues::GRADLE_AAB_OUTPUT_PATH]
      UI.user_error!("âŒ No AAB generated") unless generated_aab_path

      upload_to_play_store(
        track: 'internal',
        release_status: 'completed',
        aab: generated_aab_path,
        skip_upload_metadata: true,
        skip_upload_images: true,
        skip_upload_screenshots: true,
        skip_upload_apk: true
      )
      UI.success("ğŸš€ Deployed to Play Store!")
    else
      UI.success("ğŸ“¦ Artifacts built successfully (Upload skipped)")
    end
  end

  desc "Build and Distribute to Play Store + GitHub"
  lane :distribute do
    # No arguments needed, it trusts the repo state
    prepare_release_artifacts(upload_to_store: true)
  end

  desc "Build Release Candidates Only (No Play Store Upload)"
  lane :build_release_candidates do |options|
    # Allows manual override if needed via "fastlane ... version_code:123"
    prepare_release_artifacts(
        upload_to_store: false,
        version_code: options[:version_code]
    )
  end
end